# Developing in Python

Python is supported in bazel with the [rules_python](https://github.com/bazelbuild/rules_python). We also use an
extension for gazelle provided by this repository to simplify the developer experience with python.

So while migration is made to be easier, try to familiarize yourself with the [bazel](../bazel/README.md) early on.

## Python 2 vs Python 3

Currently, our repository only provides support for python 3. If there is a hard requirement for python 2, please
contact the repository maintainers. However, it is _strongly_ recommended trying to move to python 3, first.

## Building and Testing

We use a tool called `gazelle` to help automate the creation and management of the BUILD files of python projects. If
you haven't yet, please read about [Developing with Gazelle](./../gazelle/README.md). You should be able to write python
as you normally would, but use `bazel run //:gazelle` to automatically update your build files, and bazel to build and
test code.

If you need to manually adjust build or test targets in bazel, please read more about the options and rules available in
the [rules_python](https://github.com/bazelbuild/rules_python) repository. While gazelle can autogenerate missing
targets and settings, everything is fully customizable.

Note! Gazelle will ignore packages that do not contain an __init__.py or __main__py file, which will lead to the
package's Python source code being added to the incorrect BUILD file. To ensure that a BUILD file is generated for all
packages, ensure that every package contains either an __init__.py or __main__.py file, even if it is zero bytes long.

### Example Structure

To help understand what will be discussed below, such as packaging, importing, binary creation, etc., we will use the
following sample project structure to reference throughout the guide.

```
projects/sample
├── foo
│   ├── BUILD.bazel  # targets can be autogenerated by gazelle
│   ├── foo.py
│   └── __init__.py
│
├── bar/
│   ├── BUILD.bazel  # targets can be autogenerated by gazelle
│   └── __init__.py
│
├── cmd/
│   ├── BUILD.bazel  # targets can be autogenerated by gazelle
│   └── __main__.py
│
└── BUILD.bazel      # optional for project level declaratives
```

### Packages

Python supports two different packaging styles as-of version 3.3. They are
[regular packages](https://docs.python.org/3/reference/import.html#regular-packages) and
[namespace packages](https://docs.python.org/3/reference/import.html#namespace-packages). Within our monorepo, we
heavily encourage utilizing the regular packaging option. When writing your code, each package should contain
a `__init__.py` file. This file is allowed to be empty, as its primary purpose is to denote the regular package. Regular
packages also allows gazelle to easily find, and construct your dependencies for the python targets in the BUILD files.

As seen in our [example project](#example-structure), called `sample`, we have declared two packages: `foo` and `bar`.
These packages have the required `__init__.py` file, which will help gazelle identify the package is a `py_library`
bazel target, and allow us to import it following the rules of regular packages.

*Note: If you have a particular need for **namespace packaging**, you may try to set it up, but support in the tooling
may be limited. This should only be done for advanced use cases. If you need help, please
[contact us](./../../technical_notes/troubleshooting.md#contact).*

### Importing Project Packages

In python there are many ways to import packages within your project. Most, if not all, should be viable for python in
bazel. However, because you may want to use gazelle to help manage your BUILD files, we will provide recommended
approaches. These recommendations also assume that the project is using [regular packages](#packages) as recommended
above.

If you have a use case that extends beyond the default capabilities of what the gazelle plugin provides for imports, you
can always manually configure import options per python rule. Please read the
[arguments section](https://bazel.build/reference/be/python#py_library_args) for more details in the python
documentation for bazel.

#### Monorepo Root as Python Root

The default behaviour with bazel and gazelle is to treat the monorepo root as the python project root directory for
import statements. This requires zero configuration in your project, and is considered the default behaviour. If you
follow this approach, all imports need to be referenced with the monorepo root as the starting point for project
imports.

Let's look at the following example files from the [example structure](#example-structure):

```python
# file: projects/sample/foo/__init__.py
```

```python
# file: projects/sample/foo/foo.py
def word():
    return "foo"
```

```python
# file: projects/sample/bar/__init__.py
from projects.sample.foo import foo


def word():
    return foo.word() + "bar"
```

In our `bar/__init__.py` we have the import statement `from projects.sample.foo import foo`. This path, is the default
expected path for gazelle to auto-determine your dependencies. It assumes you are using the monorepo root as the root
for your python project, so all imports must be the full path. This behaviour is the default.

After running gazelle, we should see targets similar to:

```bazel
# file: projects/sample/foo/BUILD.bazel

py_library(
    name = "foo",
    srcs = [
        "__init__.py",
        "foo.py",
    ],
    imports = ["../../.."],
    visibility = ["//:__subpackages__"],
)
```

```bazel
# file: projects/sample/foo/BUILD.bazel

py_library(
    name = "bar",
    srcs = [
        "__init__.py",
    ],
    imports = ["../../.."],
    deps = ["//projects/sample/foo"],
    visibility = ["//:__subpackages__"],
)
```

#### Custom Directory as Python Root

If your project wishes to use imports relative specifically to your project's directory, then you must specify a special
gazelle option. In your project's root add to a `BUILD.bazel` file, the following: `# gazelle:python_root`. This
declarative comment will inform gazelle to treat that directory as the python root for all subdirectory python packages.

Now let's look at an example of how this would be setup and used with example files from the
[example structure](#example-structure):

```
# file: projects/sample/BUILD.bazel

# gazelle:python_root
```

```python
# file: projects/sample/foo/__init__.py
```

```python
# file: projects/sample/foo/foo.py
def word():
    return "foo"
```

```python
# file: projects/sample/bar/__init__.py
from foo import foo


def word():
    return foo.word() + "bar"
```

As we can see here, compared to the [monorepo root](#monorepo-root-as-python-root) approach, the import statement is now
relative to our `project/sample` directory. When it comes to runtime capabilities, there is effectively no difference
between either option.

*Note: Do not use the full path `projects.sample.foo` with this approach. as this currently causes issues with gazelle.
Your code will still build and run as expected, but gazelle will result in an error.*

After running gazelle, we should see targets similar to:

```bazel
# file: projects/sample/foo/BUILD.bazel

py_library(
    name = "foo",
    srcs = [
        "__init__.py",
        "foo.py",
    ],
    imports = [".."],
    visibility = ["//projects/sample:__subpackages__"],
)
```

```bazel
# file: projects/sample/foo/BUILD.bazel

py_library(
    name = "bar",
    srcs = [
        "__init__.py",
    ],
    imports = [".."],
    deps = ["//projects/sample/foo"],
    visibility = ["//projects/sample:__subpackages__"],
)
```

#### Import Visibility

One difference between the two options mentioned above, [Monorepo Root as Python Root](#monorepo-root-as-python-root) vs
[Custom Directory as Python Root](#custom-directory-as-python-root) is target visibility. If you run gazelle, and python
rules do not yet exist, it will use the python root directory as the target for visibility. For example:

* Monorepo Root creates rules with `visibility = [//:__subpackages__]`
* Custom Directory (using the above example) creates rules with `visibility = [//projects/sample:__subpackages__]`

This has no impact on how your application is run, but changes what directories are allowed to import your python
targets. If you manually change the setting on a target, gazelle will keep your adjustments, so which option you pick
does not limit you. However, it is important to understand the default behavior.

It is encouraged to limit the visibility scope of your rules relative to your project if you do not want other projects
to import it. This setting prevents other projects from importing and using your project that may not be intended for
consumption. If you would like to know more details, please read more from bazel's
[visibility documentation](https://bazel.build/concepts/visibility).

## Binaries

In python, a binary target is created when you have a package target contains a file named `__main__.py`. This file
will indicate to gazelle that it is the main run file for the package. Without this file, gazelle will never
automatically create a binary target for your python project. When present however, gazelle will automatically create a
`py_binary` target in the BUILD file.

```bazel
# file: projects/sample/cmd/BUILD.bazel
load("@rules_python//python:defs.bzl", "py_binary")

py_binary(
    name = "cmd",
    srcs = ["__main__.py"],
    imports = ["../../.."],
    main = "__main__.py",
    visibility = ["//:__subpackages__"],
    deps = ["//projects/sample/bar"],
)
```

## Updating Dependencies

The monorepo uses py_requirements.in, wrapped by bazel, to manage our python dependencies. Adding, removing, or updating
dependencies requires a few commands though.

Relevant Files:

* [py_requirements.in](../../../py_requirements.in)
    * Manually maintained file.
    * File to specify which packages are needed for our python projects.
    * [Format Documentation](https://pip.pypa.io/en/stable/reference/requirements-file-format/#requirements-file-format)
* [py_requirements.txt](../../../py_requirements.txt)
    * Auto-generated file. However, versions can be modified if they are not pinned in the py_requirements.in file.
* [py_gazelle.yaml](../../../py_gazelle.yaml)
    * Auto-generated file.
    * A special mapping file for gazelle to map bazel python dependencies in the BUILD python rules.

#### Adding a package

To add a pip package, just append your package name to the
[py_requirements.in](../../..//py_requirements.in) file. While it is recommended to specify the
version you want in this file, it is not necessary. If you do not specify the version, then the latest version will
automatically get pinned in the lock file. It is recommended to then manually add that version to the py_requirements.txt
file. While not necessary, it keeps the versions more clear for future reviewers who wish to update package version.

Afterwards, please run the [requirement commands](#requirement-commands). After running these commands, you should see
the auto-generated files have added new lines for your new pip package and any relevant dependencies it has.

#### Removing a package

To remove a pip package, you can delete the package name from the
[py_requirements.in](../../../py_requirements.in) file.

Afterwards, please run the [requirement commands](#requirement-commands). After running these commands, you should see
the auto-generated files have removed the packages relevant to the pip package you removed.

#### Updating a package

When updating a pip package, it is recommended to pin the desired version in the
[py_requirements.in](../../../py_requirements.in) file. You can do this by specifying the new version
after the package name, such as, `camelcase==0.2`. If the pip package you wish to update is not pinned, then you can
just add the specific version.

Afterwards, please run the [requirement commands](#requirement-commands). After running these commands, you should see
the auto-generated files have been modified for your new pip package version and any relevant dependencies it has.

### Requirement Commands

Because we are using bazel for our build tool, it is important to maintain a hermetic environment. This means we must
pin, with the hash, the specific version of a package we use. Also, to fully support gazelle for python, we need to map
our requirements into a form that will allow gazelle to auto-add dependencies to our python rules. To do these two
things, we can simply run three commands after adding, removing, or modifying pip packages.

NOTE: These steps __must__ be performed on Linux. If they are executed on Windows or Mac OS, the dependency list will
not be updated correctly, and your PR will fail on CI.

The first command updates the py_requirements.txt file:

```shell
bazel run //:py_requirements.update
```

The second command updates the gazelle_python.yaml file:

```shell
bazel run //:gazelle_python_manifest.update
```

And the final command ensures that everything is good to go:

```shell
bazel test //:py_requirements_test
```

If you get the following error:

```
ERROR: Target //:py_requirements_test is incompatible and cannot be built, but was explicitly requested.
Dependency chain:
    //:py_requirements_test (850da0)   <-- target platform (@local_config_platform//:host) didn't satisfy constraints [@platforms//cpu:x86_64, @platforms//os:linux]
```

Then this means that you are running on an incompatible platform (Mac OS or Windows) and must perform the steps on
Linux before you push the updated files to GitHub and create a PR!

*Note: The //:py_requirements_test target will be executed on CI when the PR is created, so if you forget to
run either of the update commands mentioned above, it will detect that the files are out of date, and the CI build
will fail until you perform the steps outlined above.*
