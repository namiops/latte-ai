# Welcome

このチュートリアルとそれに関連するコードは、Agora のサービスバスを理解するために用意されています。Agoraはこのサービスバスを用いて、サービスが非同期のワークフローを実行する共通の方法を提供しています。これを実現するために、Agoraでは[**Apache Kafka**](https://kafka.apache.org/)を利用しています。

## Why Agora Picked Kafka

Kafkaは、大量のデータを扱うことができるイベントストリーミングプラットフォームとして有名で、次のような特徴があります。

* 性能
  * Kafkaの大きな特徴の1つである高い処理能力は、メッセージを短時間で大量に配信することができます。
* スケーラビリティ
* 完全性
  * ストリームは耐久性と耐障害性に優れています。
* 高い可用性
  * 複数のゾーンやマルチテナント/マルチクラスターセットアップで機能します。

これらの理由から、AgoraはKafkaを試してみることにしました。詳細については、チームの [**Technical Note**](https://docs.google.com/document/d/1VhuUh3RzaSowKTjuq1NtDjQ9lfAHntJe4tLPSg0iAio/edit#heading=h.5qm13wuvtiz9) を参照してください。




## When To Use Asynchronous Communication

ソフトウェア開発において、非同期設計をすることでとてもうまくいくワークフローがいくつかあります。いくつかの例をご紹介します。

* UIをレスポンシブにする
  * 例えば、2つのボタンを持つモバイルアプリの場合、2つのボタンはそれぞれ独立した機能を持っています。一つはボタンの色を変え、もう一つはデータを取得します。一方のボタン操作で、他方のボタン操作を阻害してはなりません。 非同期プログラミングは、これをサポートします。
* ファイア・アンド・フォーゲット (Fire and Forget)
  * あるサービスが通知を送信する必要があるとします。通知を送信するロジックは、送信タイミングを決めるロジックから切り離すことができます。サービスは、特定のユースケースでメッセージを送信する必要があることを知るだけです。非同期プログラミングで他のサービスにメッセージを送り、応答を待つことなく、そのサービスに処理を任せることができます。
* サーバーで効果的にスケーリングする
  * バックエンドのサービスにおいて、データベースを大量に呼び出す場合、非同期プログラミングを使用することで、これらの呼び出しを一括して処理することができます。

!!! Note

    Agoraで重要なことは、**同期フローは完全に許容範囲内であり、多くの場合、非同期フローよりも適している**ということです。 サービスバスの目的は、サービスが非同期で動作するための共通の方法を提供するよう支援することですが、同期フローも単に問題ないだけでなく、時には必要な場合もあります。

## What This Tutorial Covers

このチュートリアルでは、ネームスペースが異なる2つのサービスが、Kafka（kafka自身は独自のネームスペースに存在します）を使用してお互いに通信する例を示します。**プロデューサー**は、一つの「バター」を製造します。そして、ある**トピック**で、バターが作られたことをみなに知らせるメッセージをサービスバスに**パブリッシュ**します。

![kafka](./assets/kafka-overview.png)

プロデューサーは、バターを作って、そのバターを食べたい人、消費したい人に対して、その通知を出すことだけを気にしていれば良いのです。送ったバターが誰に届いたかどうかなどの問題は、プロデューサー自身とは別の問題であるため、確認する必要はありません。

一方、プロデューサーが作ったバターに興味を持つ**コンシューマー**がいるとします。そのタスクを達成するために、コンシューマはプロデューサーがバターを送っている**トピック**を**購読（サブスクライブ）**し、そして作られたバターを消費します。

このようにサービスを設定することで、プロデューサーがバターの製造工程を改善しても、コンシューマーがバターの消費方法を変えても、お互いに影響しないように、お互いの活動を阻害することもなく、コンシューマーとプロデューサーが疎結合になっています。

## Pre-requisites For The Tutorial

このチュートリアルでは、以下のものがローカルにインストールされている必要があります。

* **Minikube**
  * Minikubeはバッキングドライバが必要ですが、このチュートリアルでは**Docker**を使用しています。
    説明は[**こちら**](https://minikube.sigs.k8s.io/docs/drivers/docker/)をご覧ください。
  * 手順については、Windows版、Mac版、Linux版のいずれも [**minikube site**](https://minikube.sigs.k8s.io/docs/start/)　に掲載されています。
  * 備考：Kafkaを導入する場合、minikubeのデフォルトのメモリ設定では不十分な場合があります。**minikube**クラスタ起動時に ``--memory=4096`` を追加して、メモリを指定するのがよいでしょう。
* **Kubectl**
  * Windows版、Mac版、Linux版のインストール方法は[**こちら**](https://kubernetes.io/docs/tasks/tools/) をご覧ください。

また、今回のチュートリアルでは、**ソースプロジェクトのルート**で作業していることを条件としていますが、これは私たちの目的のためです。

```shell
/ns/tutorial/kafka-101/
```
